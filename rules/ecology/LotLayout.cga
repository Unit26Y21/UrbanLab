/**
 * File:    LotLayout.cga
 * Created: 13 Nov 2021 03:18:10 GMT
 * Author:  nlaveau000
 */

version "2021.0"

import ecology: "ecology.cga"
import meterConverter: "MeterToFeet.cga" #this needs to match exactly the name of the file

#### ATTRIBUTES ####
#added this to give you more variation on that interior ecology
@Range(min = 0, max = 50)
attr blockRearYard = 20 #this needs to be .feet. When in doubt, open the file you are importing to revise what are the available functions or rules

@Range(min = 3, max = 10)
	attr arcadeDepth = meterConverter.feet(9)

	attr columnMatrix = [3,4]
	
@Range(min=0, max=1)
attr colorValue = 1	
	
### TEXTURES ###

const FacadeTexture = "facades/textures/" + "Wintercreeper.jpg"	

#### RULES ####

/*#Scenario 1: Setbacks on all Sides
# use StartRule to manage your different scenarios. You can use the same rule but different starting points
@StartRule
LowDensityLot -->	setback(meterConverter.meterTofeet(16)){	  street.front = Garden
					| street.back = Garden
					| street.left = Garden 
					| street.right = Garden 
					| remainder: LowDensityBuilding } 
LowDensityBuilding --> 
	extrude(world.up, meterConverter.feet(rand(16, 50)))
	keep.*/





#Scenario 2: Setbacks behind for internal couryard
@StartRule
HighDensityLot --> 
	setback(meterConverter.feet(blockRearYard)) { 	street.back = Garden | 
													remainder: HighDensityBuilding }

HighDensityBuilding --> 
	extrude(world.up, meterConverter.feet(rand(200)))
	SplitBuilding
	
Garden --> 
	color("#567d46")
	
#Going up from ground floor
#Split building sides into floors
# the problem here is that you need to deploy split() inside a RULE

SplitBuilding -->
	label("building")
	split(y){meterConverter.feet(15): comp(f){street.front: FirstFloor 
											 |street.back: NIL	 
											 |street.right: NIL
											 |street.left: NIL
											 |object.bottom: FirstFloorColumns}  
			| ~1: 	 OtherFloors
			} 
	
			
####COLUMNS###
FirstFloorColumns -->
	split(x){columnMatrix[0]: 
			split(y){columnMatrix[1]:
				PlaceColumn}}
				
PlaceColumn -->
	comp(v){all: DrawColumn}

DrawColumn -->
	rotateScope(270,0,0)
	primitiveQuad(0.5,0.5)
	extrude(6)
				
FirstFloor --> 	
	extrude(arcadeDepth)
	alignScopeToAxes(y)
	comp(f){0: Columnade
			| 1: Columnade
			| 4: TopColumade}

Columnade -->
	split(x){ 0.5: DrawColumnHorizontally
			| 3: NIL
			| 0.5: DrawColumnHorizontally
			| 4: NIL
			}*
DrawColumnHorizontally -->
	extrude(-0.5)

TopColumade -->
	offset(-1, all)
	extrude(1)


OtherFloors --> 
	split(y){meterConverter.feet(12): SlideFloors | meterConverter.feet(12): DontSlideFloors  keep.}*


###Balcony Tiles

Floors -->
	comp(f){ object.top: FloorTop 
			   | street.front: Tile 
			   | street.back:Tile 
			   | street.right: Tile 
			   | street.left: Tile}

FloorTop -->
	color(1,1,1,0.5)
		 
	
###Attempting to select Horizontal space as a result of sliding
###and calculate the area for run off savings

#SplitHspace -->
#	comp(f) {top : FloorArea}keep.

	
#removeCoveredHspace -->
	#case overlaps: NIL
	#else: 
	#	 comp(f) {top : BalconyArea}keep.
	#	report("Balcony Area", geometry.area())



Tile --> 
	# you need to split this on x only
	# keep in mind that if you do a split on y it might render the balcony uninhabitable. just saying
	# you do not need to repeat 9 feet 4 times unless you plan on having different dimensions
	split(x){ meterConverter.feet(9): Balcony }*
    
	
Balcony --> 
	extrude(meterConverter.feet(rand(2,6 )))
	label("balcony")
	CheckClashOtherBuildings
	
#Checking for balconies when the sideyard is 0 feet
CheckClashOtherBuildings -->
	case overlaps(inter, "building"): NIL
	else:
		comp(f){ object.top: BalconyTop 
		   	   | street.front: Facade
		   	   | all: keep.}

Facade -->
	setupProjection(0, scope.xy, 5, 5)
	texture(FacadeTexture)
	projectUV(0)
	
colorTiles -->
	color("#608341")
	#color("#83F52C")
	#color ( colorRamp("spectrum",colorValue))
	#color(rand(1), rand(1), rand(1))#texture(FacadeTexture)

	
BalconyTop -->
	splitBalcony
	
########This was done for the "balcony" which is now not the area that is regarded as the horizontal space. 	
# we moved this to here...
splitBalcony -->
	# the finer the grane the smaller the split for the top of the balcony
	split(y){meterConverter.feet(0.5): removeCoveredBalcony}*
		

removeCoveredBalcony -->
	# make sure you use touches instead of overlaps for occlusion
	# queries between 3D and 2D shapes
	case touches(intra, "balcony"): keep.
	else: 
		ecology.ReportTopSurfaces("Balcony")
		
BalconyArea-->
	color("#800080")

DontSlideFloors -->
	case split.index < 0:
		DoNothing. #at first floor

	else:
		case split.index +1 == split.total:
			Floors
			ecology.ReportTopSurfaces("Roofs")
	
			
		else:
			Floors
			
SlideFloors -->
	case split.index < 0:
		DoNothing. #at first floor

	else:
		case split.index +1 == split.total:
			translate(rel, object, meterConverter.feet (rand(20)),0,meterConverter.feet(rand(20)) )
			Floors
			ecology.ReportTopSurfaces("Roofs")
	
			
		else:
			translate(rel, object, meterConverter.feet (rand(20)),0,meterConverter.feet(rand(20)) )
			Floors
			
	
#Reports 	
Lot -->
	ecology.Lot

SelectTopSurfaces -->
	ecology.SelectTopSurfaces



