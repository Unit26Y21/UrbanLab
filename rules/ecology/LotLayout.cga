/**
 * File:    LotLayout.cga
 * Created: 13 Nov 2021 03:18:10 GMT
 * Author:  nlaveau000
 */

version "2021.0"

#import ecology: "ecology.cga"

#### ATTRIBUTES ####
#added this to give you more variation on that interior ecology
@Range(min = 0, max = 100)
attr blockRearYard = 5

<<<<<<< Updated upstream
@Range(min = 3, max = 10)
attr arcadeDepth = 3
=======
@Range(min = 0, max = 50)
attr SideYard = 5 #this needs to be .feet. When in doubt, open the file you are importing to revise what are the available functions or rules
>>>>>>> Stashed changes

attr columnMatrix = [3,4]
<<<<<<< Updated upstream
=======
	
@Range(min=0, max=1)
attr colorValue = 1	
	
### TEXTURES ###

const FacadeTexture = "facades/textures/" + "Hatch 6.jpg"	
>>>>>>> Stashed changes

#### RULES ####

/*#Scenario 1: Setbacks on all Sides*/
# use StartRule to manage your different scenarios. You can use the same rule but different starting points
@StartRule
LowDensityLot -->	setback(5){	  street.front = Garden
					| street.back = Garden 
					| street.left = Garden 
					| street.right = Garden 
					| remainder: LowDensityBuilding }
    	
Garden --> 
	color("#567d46")

LowDensityBuilding --> 
	extrude(world.up, rand(5, 15))keep.


#Scenario 2: Setbacks behind for internal couryard
HighDensityLot --> setback(rand(5, blockRearYard)) { street.back = Garden| street.right = Garden | street.left = Garden|street.front = Garden 
        					   | remainder: HighDensityBuilding }

HighDensityBuilding --> 
	extrude(world.up, (50))
	report("height", geometry.height())
	SplitBuilding


#Going up from ground floor
#Split building sides into floors
# the problem here is that you need to deploy split() inside a RULE

SplitBuilding -->
<<<<<<< Updated upstream
	split(y){6: comp(f){street.front: FirstFloor |street.back:FirstFloor	 | street.right:FirstFloor |street.left:FirstFloor
						|object.bottom: FirstFloorColumns}  
			| ~1: OtherFloors
			}
####COLUMS###
=======
	label("building")
	split(y){meterConverter.feet(15): comp(f){street.front: FirstFloor. 
											 |street.back: NIL	 
											 |street.right: NIL
											 |street.left: NIL
											 |object.bottom: FirstFloorColumns}  
			| ~1: 	 OtherFloors
			} 
	set(floorNo, split.index + 1)
/*			
####COLUMNS###
>>>>>>> Stashed changes
FirstFloorColumns -->
	split(x){columnMatrix[0]: 
			split(y){columnMatrix[1]:
				PlaceColumn}}
				
PlaceColumn -->
	comp(v){all: DrawColumn}

DrawColumn -->
	rotateScope(270,0,0)
	primitiveQuad(0.5,0.5)
	extrude(6)
				
FirstFloor --> 	
	extrude(arcadeDepth)
	alignScopeToAxes(y)
	comp(f){0: Columnade
			| 1: Columnade
			| 4: TopColumade}

Columnade -->
	split(x){ 0.5: keep.
			| 3: NIL
			| 0.5: keep.
			| 4: NIL
			}*

TopColumade -->
	offset(-1, all)
	extrude(1)
<<<<<<< Updated upstream
###
=======
*/

OtherFloors --> 
	split(y){meterConverter.feet(12): SlideFloors | meterConverter.feet(12): DontSlideFloors  keep. }* 
	#set(floorNo, split.index + 1)
	#set(floorNo, split.index + 1)
>>>>>>> Stashed changes

OtherFloors --> split(y){5:SlideFloors |5:Floors keep.}*
###Balcony Tiles
Floors -->

		comp(f){street.front: Tile | street.back:Tile | street.right: Tile | street.left: Tile}

	
Tile --> 
		split(x){ 3: Balcony | 3: Balcony | 3: Balcony }*
		split (y){1:Balcony | 1: Balcony | 1:Balcony}*
		
Balcony --> 
	extrude(rand(1,3 ))		
	comp(f){object.top: BalconyTop | all: keep.}
	#color 

<<<<<<< Updated upstream
=======
Facade -->
	setupProjection(0, scope.xy, 5, 5)
	texture(FacadeTexture)
	projectUV(0)
	
#colorTiles -->
#	color("#608341")
	#color("#83F52C")
	#color ( colorRamp("spectrum",colorValue))
	#color(rand(1), rand(1), rand(1))#texture(FacadeTexture)

	
>>>>>>> Stashed changes
BalconyTop -->
	
	splitBalcony
	


/*
	
Floors -->
	#select the Tiles of the floor
	comp(f){object.side: balconies | all: otherColor}
 	
 	
 balconies --> 
 	print(getTreeKey())
 	extrude(float(listItem(getTreeKey(),1)))
 	topBalconies 
 	
 topBalconies --> comp(f){top: ReportBalconieArea |	
 						 all: NIL}
 
ReportBalconieArea -->
	report("balconie area", geometry.area())					
 	color(0,1,0)
 
 
 floorColor --> color(rand(1),rand(1), rand(1))  
 
 otherColor --> color(1,0,0)	*/


splitBalcony -->
	split(y){1: removeCoveredBalcony}*
		
removeCoveredBalcony -->
	case overlaps: NIL
	else: 
		color
		report("Balcony Area", geometry.area())
		

<<<<<<< Updated upstream
color -->
	color("#90EE90")
	###
=======
DontSlideFloors -->

	case split.index < 1:
		DoNothing. #at first floor
		#set(floorNo, split.index + 1) 
	else:
		case split.index +1 == split.total:
			set(floorNo, split.index + 1) 
			Floors
			ecology.ReportTopSurfaces("Roofs")
	
		else:
			Floors
	
>>>>>>> Stashed changes

SlideFloors -->
case split.index < 1:
		DoNothing. #at first floor
	else:
<<<<<<< Updated upstream
		translate(rel, object, rand(8),0,rand(8) )
		#split (y){1:Balcony | 1: Balcony | 1:Balcony}*
		Floors
		keep.
		#Lot
=======
		case split.index +1 == split.total:
			translate(rel, object, meterConverter.feet (rand(20)),0,meterConverter.feet(rand(20)) )
			Floors
			ecology.ReportTopSurfaces("Roofs")
	
			
		else:
			translate(rel, object, meterConverter.feet (rand(20)),0,meterConverter.feet(rand(20)) )
			Floors

Commercial -->
	case floorNo <= 3:  comercial.Retailsize 
	else: HighDensityLot


>>>>>>> Stashed changes
	
#Reports 	
Lot -->
	ecology.Lot

SelectTopSurfaces -->
	ecology.SelectTopSurfaces

ReportTopSurfaces -->
	ecology.ReportTopSurfaces

